---
--- prefix_range datatype installation
---
BEGIN;

DROP TYPE IF EXISTS prefix_range CASCADE;

CREATE OR REPLACE FUNCTION prefix_range_in(cstring)
RETURNS prefix_range
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_out(prefix_range)
RETURNS cstring
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE TYPE prefix_range (
	INPUT = prefix_range_in,
	OUTPUT = prefix_range_out
);
COMMENT ON TYPE prefix_range IS 'prefix range: (prefix)?([a-b])?';

CREATE OR REPLACE FUNCTION prefix_range(text)
RETURNS prefix_range
AS 'MODULE_PATHNAME', 'prefix_range_cast_from_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION text(prefix_range)
RETURNS text
AS 'MODULE_PATHNAME', 'prefix_range_cast_to_text'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE CAST (text as prefix_range) WITH FUNCTION prefix_range(text);
CREATE CAST (prefix_range as text) WITH FUNCTION text(prefix_range);


CREATE OR REPLACE FUNCTION prefix_range_eq(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_neq(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_lt(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_le(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_gt(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_ge(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_cmp(prefix_range, prefix_range)
RETURNS integer
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_overlaps(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contains(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contains_strict(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contained_by(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contained_by_strict(prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contains_prefix(prefix_range, text)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_contained_by_prefix(text, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_union(prefix_range, prefix_range)
RETURNS prefix_range
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_range_inter(prefix_range, prefix_range)
RETURNS prefix_range
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OPERATOR << (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contained_by_strict,
	COMMUTATOR = '>>',
	RESTRICT = contsel,
	JOIN = contjoinsel
);
COMMENT ON OPERATOR <<(prefix_range, prefix_range) IS 'contained by strict?';

CREATE OPERATOR <<= (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contained_by,
	COMMUTATOR = '>>=',
	RESTRICT = contsel,
	JOIN = contjoinsel
);
COMMENT ON OPERATOR <<=(prefix_range, prefix_range) IS 'contained by?';

CREATE OPERATOR && (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_overlaps,
	COMMUTATOR = '&&',
	RESTRICT = areasel,
	JOIN = areajoinsel
);
COMMENT ON OPERATOR &&(prefix_range, prefix_range) IS 'overlaps?';

CREATE OPERATOR >> (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contains_strict,
	COMMUTATOR = '<<',
	RESTRICT = contsel,
	JOIN = contjoinsel
);
COMMENT ON OPERATOR >>(prefix_range, prefix_range) IS 'contains strict?';

CREATE OPERATOR >>= (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contains,
	COMMUTATOR = '<<=',
	RESTRICT = contsel,
	JOIN = contjoinsel
);
COMMENT ON OPERATOR >>=(prefix_range, prefix_range) IS 'contains?';

CREATE OPERATOR = (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_eq,
	COMMUTATOR = '=',
	NEGATOR = '<>',
	RESTRICT = eqsel,
	JOIN = eqjoinsel
);
COMMENT ON OPERATOR >>=(prefix_range, prefix_range) IS 'equals?';

CREATE OPERATOR <> (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_neq,
	COMMUTATOR = '<>',
	NEGATOR = '=',
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
COMMENT ON OPERATOR >>=(prefix_range, prefix_range) IS 'not equals?';

CREATE OPERATOR < (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_lt
);
COMMENT ON OPERATOR <(prefix_range, prefix_range) IS 'less-than';

CREATE OPERATOR <= (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_le
);
COMMENT ON OPERATOR <=(prefix_range, prefix_range) IS 'less-than-or-equal';

CREATE OPERATOR > (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_gt
);
COMMENT ON OPERATOR >(prefix_range, prefix_range) IS 'greater-than';

CREATE OPERATOR >= (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_ge
);
COMMENT ON OPERATOR >=(prefix_range, prefix_range) IS 'greater-than-or-equal';

CREATE OPERATOR | (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_union
);
COMMENT ON OPERATOR |(prefix_range, prefix_range) IS 'union';

CREATE OPERATOR & (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_inter
);
COMMENT ON OPERATOR &(prefix_range, prefix_range) IS 'intersection';

CREATE OPERATOR @> (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contains,
	COMMUTATOR = '<@'
);
COMMENT ON OPERATOR @>(prefix_range, prefix_range) IS 'contains?';

CREATE OPERATOR @> (
	LEFTARG = prefix_range,
	RIGHTARG = text,
	PROCEDURE = prefix_range_contains_prefix,
	COMMUTATOR = '<@'
);
COMMENT ON OPERATOR @>(prefix_range, text) IS 'prefix_range contains query?';

CREATE OPERATOR <@ (
	LEFTARG = text,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contained_by_prefix,
	COMMUTATOR = '@>'
);
COMMENT ON OPERATOR <@(text, prefix_range) IS 'prefix_range is contained by query?';

CREATE OPERATOR <@ (
	LEFTARG = prefix_range,
	RIGHTARG = prefix_range,
	PROCEDURE = prefix_range_contained_by,
	COMMUTATOR = '@>'
);
COMMENT ON OPERATOR <@(prefix_range, prefix_range) IS 'contained by?';


CREATE OPERATOR CLASS btree_prefix_range_ops
DEFAULT FOR TYPE prefix_range USING btree
AS
	OPERATOR	1	< ,
	OPERATOR	2	<= ,
	OPERATOR	3	= ,
	OPERATOR	4	>= ,
	OPERATOR	5	> ,
	FUNCTION	1	prefix_range_cmp(prefix_range, prefix_range);


CREATE OR REPLACE FUNCTION gpr_consistent(internal, prefix_range, prefix_range)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gpr_compress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gpr_decompress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gpr_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C' STRICT;

CREATE OR REPLACE FUNCTION pr_penalty(prefix_range, prefix_range)
RETURNS float4
AS 'MODULE_PATHNAME'
LANGUAGE 'C' STRICT;

CREATE OR REPLACE FUNCTION gpr_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gpr_union(internal, internal)
RETURNS text
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gpr_same(prefix_range, prefix_range, internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';


CREATE OPERATOR CLASS gist_prefix_range_ops
FOR TYPE prefix_range USING gist 
AS
	OPERATOR	1	@>,
	FUNCTION	1	gpr_consistent (internal, prefix_range, prefix_range),
	FUNCTION	2	gpr_union (internal, internal),
	FUNCTION	3	gpr_compress (internal),
	FUNCTION	4	gpr_decompress (internal),
	FUNCTION	5	gpr_penalty (internal, internal, internal),
	FUNCTION	6	gpr_picksplit (internal, internal),
	FUNCTION	7	gpr_same (prefix_range, prefix_range, internal);


COMMIT;


---
--- prefix opclass installation
---
BEGIN;

CREATE OR REPLACE FUNCTION prefix_contains(text, text)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

CREATE OR REPLACE FUNCTION prefix_contained_by(text, text)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

DROP OPERATOR IF EXISTS @>(text, text) CASCADE;
CREATE OPERATOR @> (
	LEFTARG = text,
	RIGHTARG = text,
	PROCEDURE = prefix_contains,
	COMMUTATOR = '<@'
);
COMMENT ON OPERATOR @>(text, text) IS 'prefix contains query?';

DROP OPERATOR IF EXISTS <@(text, text) CASCADE;
CREATE OPERATOR <@ (
	LEFTARG = text,
	RIGHTARG = text,
	PROCEDURE = prefix_contained_by,
	COMMUTATOR = '@>'
);
COMMENT ON OPERATOR <@(text, text) IS 'query is contained by prefix?';

--
-- greatest prefix aggregate
--
CREATE OR REPLACE FUNCTION greater_prefix(text, text)
RETURNS text
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

DROP AGGREGATE IF EXISTS greater_prefix(text);
CREATE AGGREGATE greater_prefix(text) (
       SFUNC = greater_prefix,
       STYPE = text
);
COMMENT ON AGGREGATE greater_prefix(text) IS 'greater prefix aggregate';

--
-- prefix penalty, for testing purpose
--
CREATE OR REPLACE FUNCTION prefix_penalty(text, text)
RETURNS float4
AS 'MODULE_PATHNAME'
LANGUAGE 'C' IMMUTABLE STRICT;

--
-- define the GiST support methods
--

CREATE OR REPLACE FUNCTION gprefix_consistent(internal, text, text)
RETURNS bool
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gprefix_compress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gprefix_decompress(internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gprefix_penalty(internal, internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C' STRICT;

CREATE OR REPLACE FUNCTION gprefix_picksplit(internal, internal)
RETURNS internal
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gprefix_union(internal, internal)
RETURNS text
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OR REPLACE FUNCTION gprefix_same(text, text, internal)
RETURNS internal 
AS 'MODULE_PATHNAME'
LANGUAGE 'C';

CREATE OPERATOR CLASS gist_prefix_ops
FOR TYPE text USING gist 
AS
	OPERATOR	1	@>,
	FUNCTION	1	gprefix_consistent (internal, text, text),
	FUNCTION	2	gprefix_union (internal, internal),
	FUNCTION	3	gprefix_compress (internal),
	FUNCTION	4	gprefix_decompress (internal),
	FUNCTION	5	gprefix_penalty (internal, internal, internal),
	FUNCTION	6	gprefix_picksplit (internal, internal),
	FUNCTION	7	gprefix_same (text, text, internal);

COMMIT;